
#include "stnl/migrator.hpp"
#include "stnl/blueprint.hpp"
#include "stnl/utils.hpp"
#include "stnl/logger.hpp"
#include "stnl/db.hpp"

#include <functional>
#include <future>
#include <string>
#include <sstream> // For std::stringstream
#include <format>  // Assuming C++20 std::format is available
#include <stdexcept>
#include <map>

#include <pqxx/pqxx>

#include <iostream>

namespace STNL {

  void Migrator::Table(const std::string& tableName, std::function<void(Blueprint&)> adaptFn) {
    std::string key = Utils::StringToLower(tableName);
    auto [it, inserted] = blueprints_.emplace(key, tableName);
    adaptFn(it->second);
  }

  void Migrator::Migrate(DB& db) {
    for(auto it = blueprints_.begin(); it != blueprints_.end(); ++it) {
      try {
        ApplyBlueprint(db, it->second);
      } catch(std::exception& e) {
        Logger::Err() << ("Migrator::Migrate: Error: " + std::string(e.what()));
      }
    }
  }

  std::string Migrator::GenerateSQLType(const Column& col) {
    // Note: IDENTITY is handled here as it is part of the type declaration in PostgreSQL
    switch (col.type) {
        case ColumnType::BigInt: 
            return col.identity ? "BIGINT GENERATED BY DEFAULT AS IDENTITY" : "BIGINT";
        case ColumnType::Integer: 
            return col.identity ? "INTEGER GENERATED BY DEFAULT AS IDENTITY" : "INTEGER";
        case ColumnType::SmallInt: 
            return col.identity ? "SMALLINT GENERATED BY DEFAULT AS IDENTITY" : "SMALLINT";
        case ColumnType::Numeric: 
            return std::format("NUMERIC({},{})", col.precision, col.scale);
        case ColumnType::Varchar: 
            return std::format("VARCHAR({})", col.length);
        case ColumnType::Char:
            return std::format("CHAR({})", col.length);
        case ColumnType::Text: return "TEXT";
        case ColumnType::Boolean: return "BOOLEAN";
        case ColumnType::Date: return "DATE";
        case ColumnType::Timestamp:
            // Use col.length for fractional second precision (0-6)
            return std::format("TIMESTAMP({}) WITHOUT TIME ZONE", col.length); 
        case ColumnType::UUID: return "UUID";
        case ColumnType::Bit: return std::format("BIT({})", col.length);
        case ColumnType::Undefined: 
        default: 
            return "NULL";
    }
  }

  std::string Migrator::GenerateSQLConstraints(const Column& col) {
    std::string constraints;
    if (!col.nullable) {
        constraints += " NOT NULL";
    }
    if (!col.defaultValue.empty()) {
        constraints += std::format(" DEFAULT {}", col.defaultValue);
    }
    return constraints;
  }

    std::string Migrator::GenerateCreateSQL(Blueprint& bp) {
        std::stringstream ss;
        ss << std::format("CREATE TABLE {} (\n", bp.GetTableName());
        
        const auto& columns = bp.GetColumns();
        size_t i = 0;
        for (const auto& pair : columns) {
            const Column& col = pair.second;
            ss << std::format("  {} {}{}", col.realName, GenerateSQLType(col), GenerateSQLConstraints(col));
            if (i < columns.size() - 1) {
                ss << ",";
            }
            ss << "\n";
            i++;
        }
        ss << ");";
        return Utils::FixIndent(ss.str());
    }

    // Helper to check if type and type parameters match (Length, Precision, Identity)
    static bool ColumnTypeAndParamsMatch(const Column& current, const Column& desired) {
        if (current.type != desired.type) return false;
        
        if (desired.type == ColumnType::Numeric) {
            if (current.precision != desired.precision || current.scale != desired.scale) return false;
        } else if (desired.type == ColumnType::Varchar || 
                  desired.type == ColumnType::Char || 
                  desired.type == ColumnType::Bit || 
                  desired.type == ColumnType::Timestamp) {
            if (current.length != desired.length) return false;
        }
        if (current.identity != desired.identity) return false;

        return true;
    }
    
    // --- Core ApplyBlueprint Logic ---

    void Migrator::ApplyBlueprint(DB& db, Blueprint& bp) {
        // NOTE: Removed previous Dbg/ExecAsync calls to focus on migration logic.
        std::string tableName = bp.GetTableName();
        
        // 1. Check for table existence
        bool bTableExists = db.TableExists(tableName);
        
        // If table does not exist, create the full table
        if (!bTableExists) {
            Logger::Inf() << std::format("Migrator: Table '{}' does not exist. Creating.", tableName);
            std::string createSQL = GenerateCreateSQL(bp);
            QResult r = db.Exec(createSQL);
            if (!r.ok) {
                Logger::Err() << std::format("Migrator: Failed to create table {}: {}", tableName, r.msg);
                throw std::runtime_error("Migration failed (CREATE TABLE) on " + tableName);
            }
            return; // Table created, migration complete for this blueprint
        }

        // 2. Table exists, retrieve current schema
        Blueprint oldBp = db.QueryBlueprint(tableName);
        
        // 3. Compare blueprints and generate ALTER SQL
        std::vector<std::string> alterStatements;
        
        const auto& desiredColumns = bp.GetColumns();
        const auto& currentColumns = oldBp.GetColumns();

        for (const auto& pair : desiredColumns) {
            const std::string& desiredNameLower = pair.first;
            const Column& desiredCol = pair.second;
            
            auto it = currentColumns.find(desiredNameLower);
            
            // A. Column does not exist -> ADD COLUMN
            if (it == currentColumns.end()) {
                std::string addSQL = STNL::Utils::FixIndent(std::format(R"(
                    ALTER TABLE {} ADD COLUMN {} {}{};
                )", tableName, desiredCol.realName, GenerateSQLType(desiredCol), GenerateSQLConstraints(desiredCol)));
                alterStatements.push_back(addSQL);
                Logger::Inf() << std::format("Migrator: ADD COLUMN '{}' to '{}'.", desiredCol.realName, tableName);
                continue;
            }
            
            // B. Column exists -> Check for MODIFICATIONS
            const Column& currentCol = it->second;

            // Check 1: Type and Parameters (Length, Precision, Identity)
            if (!ColumnTypeAndParamsMatch(currentCol, desiredCol)) {
                // Generate ALTER COLUMN TYPE statement
                std::string typeSQL = STNL::Utils::FixIndent(std::format(R"(
                    ALTER TABLE {} ALTER COLUMN {} TYPE {};
                )", tableName, desiredCol.realName, GenerateSQLType(desiredCol)));
                alterStatements.push_back(typeSQL);
                Logger::Inf() << std::format("Migrator: ALTER COLUMN '{}' TYPE in '{}'.", desiredCol.realName, tableName);
            }

            // Check 2: Nullability (Requires separate ALTER commands in PostgreSQL)
            if (currentCol.nullable != desiredCol.nullable) {
                std::string nullSQL;
                if (desiredCol.nullable) {
                    nullSQL = std::format("ALTER TABLE {} ALTER COLUMN {} DROP NOT NULL;", tableName, desiredCol.realName);
                } else {
                    nullSQL = std::format("ALTER TABLE {} ALTER COLUMN {} SET NOT NULL;", tableName, desiredCol.realName);
                }
                alterStatements.push_back(nullSQL);
                Logger::Inf() << std::format("Migrator: ALTER COLUMN '{}' NULLABILITY in '{}'.", desiredCol.realName, tableName);
            }
            
            // Check 3: Default Value
            if (currentCol.defaultValue != desiredCol.defaultValue) {
                std::string defaultSQL;
                if (desiredCol.defaultValue.empty()) {
                    // Remove default
                    defaultSQL = std::format("ALTER TABLE {} ALTER COLUMN {} DROP DEFAULT;", tableName, desiredCol.realName);
                } else {
                    // Set or change default
                    defaultSQL = std::format("ALTER TABLE {} ALTER COLUMN {} SET DEFAULT {};", tableName, desiredCol.realName, desiredCol.defaultValue);
                }
                alterStatements.push_back(defaultSQL);
                Logger::Inf() << std::format("Migrator: ALTER COLUMN '{}' DEFAULT in '{}'.", desiredCol.realName, tableName);
            }
        }

        // 4. Execute ALTER statements
        if (alterStatements.empty()) {
            Logger::Inf() << std::format("Migrator: Table '{}' is already up to date.", tableName);
            return;
        }

        Logger::Inf() << std::format("Migrator: Applying {} change(s) to table '{}'.", alterStatements.size(), tableName);
        
        // Execute all statements in order
        for (const std::string& sql : alterStatements) {
            // Use FixIndent for clean logging and execution
            std::string fixedSQL = STNL::Utils::FixIndent(sql); 
            QResult r = db.Exec(fixedSQL);
            if (!r.ok) {
                Logger::Err() << std::format("Migrator: Failed ALTER SQL: {} Error: {}", fixedSQL, r.msg);
                throw std::runtime_error("Migration failed (ALTER TABLE) due to SQL error on table " + tableName); 
            }
        }
        Logger::Inf() << std::format("Migrator: Change(s) applied to table {}", tableName);

    }

 
}