
#include "stnl/migrator.hpp"
#include "stnl/blueprint.hpp"
#include "stnl/utils.hpp"
#include "stnl/logger.hpp"
#include "stnl/db.hpp"

#include <functional>
#include <future>
#include <string>
#include <sstream> // For std::stringstream
#include <format>  // Assuming C++20 std::format is available
#include <stdexcept>
#include <map>

#include <pqxx/pqxx>

#include <iostream>

namespace STNL {

  void Migrator::Table(const std::string& tableName, std::function<void(Blueprint&)> adaptFn) {
    std::string key = Utils::StringToLower(tableName);
    auto [it, inserted] = blueprints_.emplace(key, tableName);
    adaptFn(it->second);
  }

  void Migrator::Migrate(DB& db) {
    for(auto it = blueprints_.begin(); it != blueprints_.end(); ++it) {
      try {
        ApplyBlueprint(db, it->second);
      } catch(std::exception& e) {
        Logger::Err() << ("Migrator::Migrate: Error: " + std::string(e.what()));
      }
    }
  }

  std::string Migrator::GenerateSQLType(const Column& col) {
    // Note: IDENTITY is handled here as it is part of the type declaration in PostgreSQL
    switch (col.type) {
        case ColumnType::BigInt: 
            return col.identity ? "BIGINT GENERATED BY DEFAULT AS IDENTITY" : "BIGINT";
        case ColumnType::Integer: 
            return col.identity ? "INTEGER GENERATED BY DEFAULT AS IDENTITY" : "INTEGER";
        case ColumnType::SmallInt: 
            return col.identity ? "SMALLINT GENERATED BY DEFAULT AS IDENTITY" : "SMALLINT";
        case ColumnType::Numeric: 
            return std::format("NUMERIC({},{})", col.precision, col.scale);
        case ColumnType::Varchar: 
            return std::format("VARCHAR({})", col.length);
        case ColumnType::Char:
            return std::format("CHAR({})", col.length);
        case ColumnType::Text: return "TEXT";
        case ColumnType::Boolean: return "BOOLEAN";
        case ColumnType::Date: return "DATE";
        case ColumnType::Timestamp:
            // Use col.length for fractional second precision (0-6)
            return std::format("TIMESTAMP({}) WITH TIME ZONE", col.precision); 
        case ColumnType::UUID: return "UUID";
        case ColumnType::Bit: return std::format("BIT({})", col.length);
        case ColumnType::Undefined: 
        default: 
            return "NULL";
    }
  }

  std::string Migrator::GenerateSQLConstraints(const Column& col) {
    std::string constraints;
    if (!col.nullable) {
        constraints += " NOT NULL";
    }
    if (!col.defaultValue.empty()) {
        constraints += std::format(" DEFAULT {}", col.defaultValue);
    }
    return constraints;
  }



  std::string Migrator::GenerateCreateSQL(Blueprint& bp) {
      std::stringstream ss;
      ss << std::format("CREATE TABLE {} (\n", bp.GetTableName());
      const auto& columns = bp.GetColumns();
      size_t i = 0;
      for (const auto& pair : columns) {
        const Column& col = pair.second;
        ss << std::format("  {} {}{}", col.realName, GenerateSQLType(col), GenerateSQLConstraints(col));
        if (i < columns.size() - 1) {
          ss << ",";
        }
        ss << "\n";
        i++;
      }
      ss << ");";
      return Utils::FixIndent(ss.str());
    }

    // Helper to check if type and type parameters match (Length, Precision, Identity)
    static bool ColumnTypeAndParamsMatch(const Column& current, const Column& desired) {
        if (current.type != desired.type) {
            Logger::Dbg() << "type-mismatch: " << current.name;
            return false;
        }
        if (desired.type == ColumnType::Numeric) {
            if (current.precision != desired.precision || current.scale != desired.scale) {
                Logger::Dbg() << "numberic-precision-mismatch: " << current.name;
                return false;
            }
        }
        else if (desired.type == ColumnType::Varchar || 
                  desired.type == ColumnType::Char || 
                  desired.type == ColumnType::Bit) {
            if (current.length != desired.length) {
                Logger::Dbg() << "(varchar|char|bit)-length-mismatch: " << current.name;
                return false;
            }
        }
        return true;
    }
    
    // --- Core ApplyBlueprint Logic ---

    void Migrator::ApplyBlueprint(DB& db, Blueprint& bp) {
        // NOTE: Removed previous Dbg/QExec calls to focus on migration logic.
        std::string tableName = bp.GetTableName();
        
        // 1. Check for table existence
        bool bTableExists = db.TableExists(tableName);
        
        // If table does not exist, create the full table
        if (!bTableExists) {
            Logger::Inf() << std::format("Migrator: Table '{}' does not exist. Creating.", tableName);
            std::string createSQL = GenerateCreateSQL(bp);
            QResult r = db.Exec(createSQL);
            if (!r.ok) {
                Logger::Err() << std::format("Migrator: Failed to create table {}: {}", tableName, r.msg);
                throw std::runtime_error("Migration failed (CREATE TABLE) on " + tableName);
            }
            return; // Table created, migration complete for this blueprint
        }

        // 2. Table exists, retrieve current schema
        Blueprint oldBp = db.QueryBlueprint(tableName);
        
        // 3. Compare blueprints and generate ALTER SQL
        std::vector<std::string> alterStatements;
        
        const auto& desiredColumns = bp.GetColumns();
        const auto& currentColumns = oldBp.GetColumns();

        for (const auto& pair : desiredColumns) {
            const std::string& desiredNameLower = pair.first;
            const Column& desiredCol = pair.second;
            
            auto it = currentColumns.find(desiredNameLower);
            
            // A. Column does not exist -> ADD COLUMN
            if (it == currentColumns.end()) {
                std::string addSQL = Utils::FixIndent(std::format(R"(
                    ALTER TABLE {} ADD COLUMN {} {}{};
                )", tableName, desiredCol.realName, GenerateSQLType(desiredCol), GenerateSQLConstraints(desiredCol)));
                alterStatements.push_back(addSQL);
                Logger::Inf() << std::format("Migrator: {}", addSQL);
                continue;
            }
            
            // B. Column exists -> Check for MODIFICATIONS
            const Column& currentCol = it->second;

            // Check 1: Type and Parameters (Length, Precision)
            if (!ColumnTypeAndParamsMatch(currentCol, desiredCol)) {
                // Generate ALTER COLUMN TYPE statement
                std::string typeSQL = Utils::FixIndent(std::format(R"(
                    ALTER TABLE {} ALTER COLUMN {} TYPE {};
                )", tableName, desiredCol.realName, GenerateSQLType(desiredCol)));

                alterStatements.push_back(typeSQL);
                Logger::Inf() << std::format("Migrator: {}", typeSQL);
            }

            // check 2: Identity check
            if (currentCol.identity != desiredCol.identity) {
                std::string identitySQL;
                if (desiredCol.identity) {
                    identitySQL = Utils::FixIndent(std::format(R"(
                        ALTER TABLE {} ALTER COLUMN {} ADD GENERATED BY DEFAULT AS IDENTITY
                    )", tableName, desiredCol.realName));
                }
                else {
                    identitySQL = Utils::FixIndent(std::format(R"(
                        ALTER TABLE {} ALTER COLUMN {} DROP IDENTITY
                    )", tableName, desiredCol.realName));
                }
                alterStatements.push_back(identitySQL);
                Logger::Inf() << std::format("Migrator: {}", identitySQL);
            }

            // Check 2: Nullability (Requires separate ALTER commands in PostgreSQL)
            if (currentCol.nullable != desiredCol.nullable) {
                std::string nullSQL;
                if (desiredCol.nullable) {
                    nullSQL = std::format("ALTER TABLE {} ALTER COLUMN {} DROP NOT NULL;", tableName, desiredCol.realName);
                } else {
                    nullSQL = std::format("ALTER TABLE {} ALTER COLUMN {} SET NOT NULL;", tableName, desiredCol.realName);
                }
                alterStatements.push_back(nullSQL);
                Logger::Inf() << std::format("Migrator: {}", nullSQL);
            }
            
            // Check 3: Default Value
            
            std::string desiredDefaultValue = std::string(desiredCol.defaultValue);
            if (desiredCol.type == ColumnType::UUID &&
                desiredCol.identity &&
                desiredCol.defaultValue.empty()) {
                  desiredDefaultValue = std::string("uuidv7()");
            }

            if (currentCol.defaultValue != desiredDefaultValue) {
                std::string defaultSQL;
                if (desiredDefaultValue.empty()) {
                    // Remove default
                    defaultSQL = std::format("ALTER TABLE {} ALTER COLUMN {} DROP DEFAULT;", tableName, desiredCol.realName);
                } else {
                    // Set or change default
                    defaultSQL = std::format("ALTER TABLE {} ALTER COLUMN {} SET DEFAULT {};", tableName, desiredCol.realName, desiredDefaultValue);
                }
                alterStatements.push_back(defaultSQL);
                Logger::Inf() << std::format("Migrator: {}", defaultSQL);
            }
        }

        // 4. Execute ALTER statements
        if (alterStatements.empty()) {
            Logger::Inf() << std::format("Migrator: Table '{}' is already up to date.", tableName);
            return;
        }

        Logger::Inf() << std::format("Migrator: Applying {} change(s) to table '{}'.", alterStatements.size(), tableName);
        // Execute all statements in order
        for (const std::string& sql : alterStatements) {
            std::string fixedSQL = Utils::FixIndent(sql); 
            QResult r = db.Exec(fixedSQL);
            if (!r.ok) {
                Logger::Err() << std::format("Migrator: Failed ALTER SQL: {} Error: {}", fixedSQL, r.msg);
                throw std::runtime_error("Migration failed (ALTER TABLE) due to SQL error on table " + tableName); 
            }
        }
        Logger::Inf() << std::format("Migrator: Change(s) applied to table {}", tableName);

    }

 
}