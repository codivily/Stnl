

#include "stnl/db/migrator.hpp"
#include "stnl/core/logger.hpp"
#include "stnl/core/utils.hpp"
#include "stnl/db/blueprint.hpp"
#include "stnl/db/column.hpp"
#include "stnl/db/db.hpp"
#include "stnl/db/migration.hpp"
#include "stnl/db/sr_blueprint.hpp"
#include "stnl/db/types.hpp"

#include <format> // Assuming C++20 std::format is available
#include <functional>
#include <future>
#include <sstream> // For std::stringstream
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

#include <pqxx/pqxx>

#include <iostream>

namespace STNL {

static auto GetConstraintName(Column const &col, std::string const &suffix) -> std::string {
    return std::format("{}_{}_{}", Utils::StringToLower(col.tableName), Utils::StringToLower(col.name), Utils::StringToLower(suffix));
}

// Forward declare helper used below to ensure ordering does not affect
// compilation when helpers are split into multiple small functions.
static auto SQLDataTypeAndParamsMatch(const Column &current, const Column &desired) -> bool;

void Migrator::Migrate(DB &db, Migration const &migration) {
    // Table migration
    std::vector<std::string> const &tableNames = migration.GetTableNames();
    std::unordered_map<std::string, Blueprint> const &blueprints = migration.GetBlueprints();
    for (std::string const &key : tableNames) {
        Blueprint const &bp = blueprints.at(key);
        try {
            ApplyBlueprint(db, bp);
        } catch (std::exception const &e) { Logger::Err() << "Migrator::Migrate: Error: " + std::string(e.what()); }
    }

    // Stored Procedure migration
    std::vector<std::string> const &spNames = migration.GetProcedureNames();
    std::unordered_map<std::string, SrBlueprint> const &spBlueprints = migration.GetProcedureBlueprints();
    for (std::string const &key : spNames) {
        SrBlueprint const &srBp = spBlueprints.at(key);
        try {
            ApplyProcedureBlueprint(db, srBp);
        } catch (std::exception const &e) { Logger::Err() << "Migrationor::Migrate: Error: " + std::string(e.what()); }
    }
}

void Migrator::Migrate(DB &db) {
    // Call the overload that accepts an explicit Migration. Avoid using
    // 'this' because this method is declared static.
    Migrator::Migrate(db, db.GetMigration());
}

// Helper builders to reduce cognitive complexity in ApplyBlueprint
auto Migrator::BuildAddColumnSQL(std::string const &tableName, Column const &desiredCol) -> std::string {
    return Utils::FixIndent(std::format(
        R"(
            ALTER TABLE {} ADD COLUMN {} {}{};
        )",
        tableName, desiredCol.realName, GenerateSQLType(desiredCol), GenerateSQLConstraints(desiredCol)));
}

auto Migrator::BuildAlterTypeSQL(std::string const &tableName, Column const &desiredCol) -> std::string {
    return Utils::FixIndent(std::format(
        R"(
            ALTER TABLE {} ALTER COLUMN {} TYPE {};
        )",
        tableName, desiredCol.realName, GenerateSQLType(desiredCol)));
}

auto Migrator::BuildIdentitySQL(std::string const &tableName, Column const &desiredCol) -> std::string {
    if (desiredCol.identity) {
        return Utils::FixIndent(std::format(
            R"(
                ALTER TABLE {} ALTER COLUMN {} ADD GENERATED BY DEFAULT AS IDENTITY
            )",
            tableName, desiredCol.realName));
    }
    return Utils::FixIndent(std::format(
        R"(
            ALTER TABLE {} ALTER COLUMN {} DROP IDENTITY
        )",
        tableName, desiredCol.realName));
}

auto Migrator::BuildNullabilitySQL(std::string const &tableName, Column const &desiredCol) -> std::string {
    if (desiredCol.nullable) { return std::format("ALTER TABLE {} ALTER COLUMN {} DROP NOT NULL;", tableName, desiredCol.realName); }
    return std::format("ALTER TABLE {} ALTER COLUMN {} SET NOT NULL;", tableName, desiredCol.realName);
}

auto Migrator::BuildDefaultValueSQL(std::string const &tableName, Column const &desiredCol, std::string const &desiredDefaultValue) -> std::string {
    if (desiredDefaultValue.empty()) { return std::format("ALTER TABLE {} ALTER COLUMN {} DROP DEFAULT;", tableName, desiredCol.realName); }
    return std::format("ALTER TABLE {} ALTER COLUMN {} SET DEFAULT {};", tableName, desiredCol.realName, desiredDefaultValue);
}

auto Migrator::BuildUniqueIndexSQL(Column const &currentCol, Column const &desiredCol) -> std::string {
    if (desiredCol.unique) {
        return std::format("CREATE UNIQUE INDEX CONCURRENTLY {} ON {} ({})", GetConstraintName(desiredCol, "key"), desiredCol.tableName, desiredCol.realName);
    }
    return std::format("DROP INDEX CONCURRENTLY IF EXISTS {}", GetConstraintName(currentCol, "key"));
}

auto Migrator::BuildIndexSQL(Column const &currentCol, Column const &desiredCol) -> std::string {
    if (desiredCol.index && !desiredCol.unique) {
        return std::format("CREATE INDEX CONCURRENTLY IF NOT EXISTS {} ON {} ({})", GetConstraintName(desiredCol, "idx"), desiredCol.tableName,
                           desiredCol.realName);
    }
    if (currentCol.index) { return std::format("DROP INDEX CONCURRENTLY IF EXISTS {}", GetConstraintName(currentCol, "idx")); }
    return std::string{};
}

void Migrator::CollectAlterStatementsForColumn(std::string const &tableName, Column const &currentCol, Column const &desiredCol,
                                               std::vector<std::string> &alterStatements) {
    if (!SQLDataTypeAndParamsMatch(currentCol, desiredCol)) {
        std::string typeSQL = BuildAlterTypeSQL(tableName, desiredCol);
        alterStatements.emplace_back(typeSQL);
        Logger::Inf() << std::format("Migrator: {}", typeSQL);
    }

    if (currentCol.identity != desiredCol.identity) {
        std::string identitySQL = BuildIdentitySQL(tableName, desiredCol);
        alterStatements.emplace_back(identitySQL);
        Logger::Inf() << std::format("Migrator: {}", identitySQL);
    }

    if (currentCol.nullable != desiredCol.nullable) {
        std::string nullSQL = BuildNullabilitySQL(tableName, desiredCol);
        alterStatements.emplace_back(nullSQL);
        Logger::Inf() << std::format("Migrator: {}", nullSQL);
    }

    std::string desiredDefaultValue = std::string(desiredCol.defaultValue);
    if (desiredCol.type == SQLDataType::UUID && desiredCol.identity && desiredCol.defaultValue.empty()) { desiredDefaultValue = std::string("uuidv7()"); }
    if (strcmp(currentCol.defaultValue.c_str(), desiredDefaultValue.c_str()) != 0) {
        std::string defaultSQL = BuildDefaultValueSQL(tableName, desiredCol, desiredDefaultValue);
        alterStatements.emplace_back(defaultSQL);
        Logger::Inf() << std::format("Migrator: {}", defaultSQL);
    }

    if (currentCol.unique != desiredCol.unique) {
        std::string uniqueIndexSQL = BuildUniqueIndexSQL(currentCol, desiredCol);
        alterStatements.emplace_back(uniqueIndexSQL);
    }

    if (currentCol.index != desiredCol.index || desiredCol.unique) {
        std::string indexSQL = BuildIndexSQL(currentCol, desiredCol);
        if (!indexSQL.empty()) { alterStatements.emplace_back(indexSQL); }
    }
}

auto Migrator::GenerateSQLType(Column const &col) -> std::string {
    // Note: IDENTITY is handled here as it is part of the type declaration in
    // PostgreSQL
    if (col.type == SQLDataType::Undefined) { throw std::invalid_argument("Undefined parameter type"); }
    switch (col.type) {
    case SQLDataType::BigInt: return col.identity ? "BIGINT GENERATED ALWAYS AS IDENTITY" : "BIGINT";
    case SQLDataType::Integer: return col.identity ? "INTEGER GENERATED ALWAYS AS IDENTITY" : "INTEGER";
    case SQLDataType::SmallInt: return col.identity ? "SMALLINT GENERATED ALWAYS AS IDENTITY" : "SMALLINT";
    case SQLDataType::Numeric: return std::format("NUMERIC({},{})", col.precision, col.scale);
    case SQLDataType::Varchar: return std::format("VARCHAR({})", col.length);
    case SQLDataType::Char: return std::format("CHAR({})", col.length);
    case SQLDataType::Text: return "TEXT";
    case SQLDataType::Boolean: return "BOOLEAN";
    case SQLDataType::Date: return "DATE";
    case SQLDataType::Timestamp:
        // Use col.length for fractional second precision (0-6)
        return std::format("TIMESTAMP({}) WITH TIME ZONE", col.precision);
    case SQLDataType::UUID: return "UUID";
    case SQLDataType::Bit: return std::format("BIT({})", col.length);
    default: throw std::invalid_argument("Unsupported column type");
    }
}

auto Migrator::GenerateSrParamSQL(SrParam const &spParam) -> std::string {
    if (spParam.type == SQLDataType::Undefined) { throw std::invalid_argument("Undefined parameter type"); }
    std::stringstream ss;
    if (spParam.in && spParam.out) {
        ss << "INOUT";
    } else if (spParam.out) {
        ss << "OUT";
    } else {
        ss << "IN";
    }
    ss << ' ' << spParam.name << ' ';

    switch (spParam.type) {
    case SQLDataType::BigInt: ss << "BIGINT"; break;
    case SQLDataType::Integer: ss << "INTEGER"; break;
    case SQLDataType::SmallInt: ss << "SMALLINT"; break;
    case SQLDataType::Numeric: ss << std::format("NUMERIC({}, {})", spParam.precision, spParam.scale); break;
    case SQLDataType::Varchar: ss << std::format("VARCHAR({})", spParam.length); break;
    case SQLDataType::Char: ss << std::format("CHAR({})", spParam.length); break;
    case SQLDataType::Text: ss << "TEXT"; break;
    case SQLDataType::Boolean: ss << "BOOLEAN"; break;
    case SQLDataType::Date: ss << "DATE"; break;
    case SQLDataType::Timestamp: ss << std::format("TIMESTAMP({}) WITH TIME ZONE", spParam.precision); break;
    case SQLDataType::UUID: ss << "UUID"; break;
    case SQLDataType::Bit: ss << std::format("BIT({})", spParam.length); break;
    default: throw std::invalid_argument("Unsupported parameter type");
    }

    if (!spParam.defaultValue.empty()) { ss << " DEFAULT " << spParam.defaultValue; }
    return ss.str();
}

auto Migrator::GenerateSQLConstraints(const Column &col) -> std::string {
    std::string constraints;
    if (!col.nullable) { constraints += " NOT NULL"; }
    if (!col.defaultValue.empty()) { constraints += std::format(" CONSTRAINT {} DEFAULT {}", GetConstraintName(col, "default"), col.defaultValue); }
    return constraints;
}

auto Migrator::GenerateCreateSQL(Blueprint const &bp) -> std::string {
    std::stringstream ss;
    ss << std::format("CREATE TABLE {} (\n", bp.GetTableName());
    std::vector<std::string> const &columnNames = bp.GetColumnNames();
    std::unordered_map<std::string, Column> const &columns = bp.GetColumns();

    size_t i = 0;
    for (std::string const &key : columnNames) {
        Column const &col = columns.at(key);
        ss << std::format("  {} {}{}", col.realName, GenerateSQLType(col), GenerateSQLConstraints(col));
        if (i < columns.size() - 1) { ss << ','; }
        ss << '\n';
        i++;
    }
    ss << ");\n";
    i = 0; // reset for reuse
    for (std::string const &key : columnNames) {
        Column const &col = columns.at(key);
        if (col.unique || col.index) {
            if (col.unique) {
                ss << std::format("CREATE UNIQUE INDEX {} ON {} ({});\n", GetConstraintName(col, "key"), col.tableName, col.realName);
            } else if (col.index) {
                ss << std::format("CREATE INDEX {} ON {} ({});\n", GetConstraintName(col, "idx"), col.tableName, col.realName);
            }
        }
        ++i;
    }
    return Utils::FixIndent(ss.str());
}

// Helper to check if type and type parameters match (Length, Precision,
// Identity)
static auto SQLDataTypeAndParamsMatch(const Column &current, const Column &desired) -> bool {
    if (current.type != desired.type) {
        Logger::Dbg() << "type-mismatch: " << current.name;
        return false;
    }
    if (desired.type == SQLDataType::Numeric) {
        if (current.precision != desired.precision || current.scale != desired.scale) {
            Logger::Dbg() << "numberic-precision-mismatch: " << current.name;
            return false;
        }
    } else if (desired.type == SQLDataType::Varchar || desired.type == SQLDataType::Char || desired.type == SQLDataType::Bit) {
        if (current.length != desired.length) {
            Logger::Dbg() << "(varchar|char|bit)-length-mismatch: " << current.name;
            return false;
        }
    }
    return true;
}

// --- Core ApplyBlueprint Logic ---

void Migrator::ApplyBlueprint(DB &db, Blueprint const &bp) {
    // NOTE: Removed previous Dbg/QExec calls to focus on migration logic.
    std::string const &tableName = bp.GetTableName();

    // 1. Check for table existence
    bool bTableExists = db.TableExists(tableName);

    // If table does not exist, create the full table
    if (!bTableExists) {
        Logger::Inf() << std::format("Migrator: Table '{}' does not exist. Creating.", tableName);
        std::string createSQL = GenerateCreateSQL(bp);
        QResult r = db.Exec(createSQL);
        if (!r.ok) {
            Logger::Err() << std::format("Migrator: Failed to create table {}: {}", tableName, r.msg);
            throw std::runtime_error("Migration failed (CREATE TABLE) on " + tableName);
        }
        return; // Table created, migration complete for this blueprint
    }

    // 2. Table exists, retrieve current schema
    Blueprint oldBp = db.QueryBlueprint(tableName);

    // 3. Compare blueprints and generate ALTER SQL
    std::vector<std::string> alterStatements;

    std::vector<std::string> const &desiredColumnNames = bp.GetColumnNames();
    auto const &desiredColumns = bp.GetColumns();
    auto const &currentColumns = oldBp.GetColumns();

    // for (const auto& pair : desiredColumns) {
    for (std::string const &desiredNameLower : desiredColumnNames) {
        Column const &desiredCol = desiredColumns.at(desiredNameLower);
        auto it = currentColumns.find(desiredNameLower);
        // A. Column does not exist -> ADD COLUMN
        if (it == currentColumns.end()) {
            std::string addSQL = BuildAddColumnSQL(tableName, desiredCol);
            alterStatements.emplace_back(addSQL);
            Logger::Inf() << std::format("Migrator: {}", addSQL);
            continue;
        }

        // B. Column exists -> Check for MODIFICATIONS (extracted to helper)
        Column const &currentCol = it->second;
        CollectAlterStatementsForColumn(tableName, currentCol, desiredCol, alterStatements);
    }

    // 4. Execute ALTER statements
    if (alterStatements.empty()) {
        Logger::Inf() << std::format("Migrator: Table '{}' is already up to date.", tableName);
        return;
    }

    Logger::Inf() << std::format("Migrator: Applying {} change(s) to table '{}'.", alterStatements.size(), tableName);
    // Execute all statements in order
    for (const std::string &sql : alterStatements) {
        std::string fixedSQL = Utils::FixIndent(sql);
        QResult r = db.Exec(fixedSQL, true);
        if (!r.ok) {
            Logger::Err() << std::format("Migrator: Failed ALTER SQL: {} Error: {}", fixedSQL, r.msg);
            throw std::runtime_error("Migration failed (ALTER TABLE) due to SQL error on table " + tableName);
        }
    }
    Logger::Inf() << std::format("Migrator: Change(s) applied to table {}", tableName);
}

void Migrator::ApplyProcedureBlueprint(DB &db, SrBlueprint const &srBp) {

    std::stringstream ss;
    ss << std::format("CREATE OR REPLACE PROCEDURE {}", srBp.GetName());
    std::unordered_map<std::string, SrParam> const &params = srBp.GetParams();
    ss << '(';
    if (!params.empty()) {
        size_t i = 0;
        for (std::string const &paramName : srBp.GetParamNames()) {
            SrParam const &spParam = params.at(paramName);
            if (i++ > 0) { ss << ", "; }
            ss << STNL::Migrator::GenerateSrParamSQL(spParam);
        }
    }
    const std::string &bodyDelimiter{srBp.GetBodyDelimiter()};
    ss << ")\n";
    ss << "LANGUAGE plpgsql\n";
    ss << "AS " + bodyDelimiter + '\n';
    ss << std::string(srBp.GetBody());
    ss << '\n' + bodyDelimiter + ";\n";
    std::string qSQL = Utils::FixIndent(ss.str());
    QResult r = db.Exec(qSQL);
    if (!r.ok) {
        Logger::Err() << std::format("Migrator: Failed CREATE OR REPLACE PROCEDURE. SQL: {} Error: {}", qSQL, r.msg);
        throw std::runtime_error("Migration failed (CREATE OR REPLACE PROCEDURE) due to SQL error. "
                                 "Procedure name: " +
                                 std::string(srBp.GetName()));
    }
    Logger::Inf() << std::format("Migrator: PROCEDURE CREATED/REPLACED: {}", srBp.GetName());
}
} // namespace STNL
